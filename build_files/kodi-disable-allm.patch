Subject: [PATCH] Add ALLM disable functionality for HDR compatibility

This patch adds content type control to disable ALLM (Auto Low Latency Mode)
when Kodi starts

---
 xbmc/windowing/gbm/drm/DRMConnector.cpp | 73 +++++++++++++++++++++++++
 xbmc/windowing/gbm/drm/DRMConnector.h   |  5 ++
 xbmc/windowing/gbm/drm/DRMUtils.cpp     | 31 +++++++++++
 3 files changed, 109 insertions(+)

diff --git a/xbmc/windowing/gbm/drm/DRMConnector.cpp b/xbmc/windowing/gbm/drm/DRMConnector.cpp
index 0000000..1111111 100644
--- a/xbmc/windowing/gbm/drm/DRMConnector.cpp
+++ b/xbmc/windowing/gbm/drm/DRMConnector.cpp
@@ -143,3 +143,76 @@ std::vector<uint8_t> CDRMConnector::GetEDID() const
 
   return edid;
 }
+
+bool CDRMConnector::SetContentType(uint32_t contentType)
+{
+  // Find the content type property
+  auto property = std::find_if(m_propsInfo.begin(), m_propsInfo.end(),
+                               [](auto& prop) { return prop->name == std::string_view("content type"); });
+
+  if (property == m_propsInfo.end())
+  {
+    CLog::LogF(LOGDEBUG, "content type property not found for connector: {}",
+               m_connector->connector_id);
+    return false;
+  }
+
+  uint32_t propertyId = (*property)->prop_id;
+  
+  // Set the property value
+  int ret = drmModeObjectSetProperty(m_fd, 
+                                     m_connector->connector_id,
+                                     DRM_MODE_OBJECT_CONNECTOR,
+                                     propertyId,
+                                     contentType);
+  
+  if (ret < 0)
+  {
+    CLog::LogF(LOGERROR, "Failed to set content type to {} for connector {}: {} ({})",
+               contentType, m_connector->connector_id, strerror(errno), errno);
+    return false;
+  }
+  
+  CLog::LogF(LOGINFO, "Successfully set content type to {} for connector {} ({})",
+             contentType, m_connector->connector_id, GetName());
+  
+  // Update the cached property value
+  auto propertyIndex = std::distance(m_propsInfo.begin(), property);
+  m_props->prop_values[propertyIndex] = contentType;
+  
+  return true;
+}
+
+uint32_t CDRMConnector::GetContentType() const
+{
+  auto property = std::find_if(m_propsInfo.begin(), m_propsInfo.end(),
+                               [](auto& prop) { return prop->name == std::string_view("content type"); });
+
+  if (property == m_propsInfo.end())
+  {
+    CLog::LogF(LOGDEBUG, "content type property not found for connector: {}",
+               m_connector->connector_id);
+    return 0;  // Default/No Data
+  }
+
+  return m_props->prop_values[std::distance(m_propsInfo.begin(), property)];
+}
+
+bool CDRMConnector::HasContentTypeProperty() const
+{
+  auto property = std::find_if(m_propsInfo.begin(), m_propsInfo.end(),
+                               [](auto& prop) { return prop->name == std::string_view("content type"); });
+  
+  return property != m_propsInfo.end();
+}
+
+bool CDRMConnector::IsHDMI() const
+{
+  return m_connector->connector_type == DRM_MODE_CONNECTOR_HDMIA ||
+         m_connector->connector_type == DRM_MODE_CONNECTOR_HDMIB;
+}
+
+bool CDRMConnector::DisableALLM()
+{
+  // Set content type to Cinema (3) to disable ALLM
+  return SetContentType(3);
+}
diff --git a/xbmc/windowing/gbm/drm/DRMConnector.h b/xbmc/windowing/gbm/drm/DRMConnector.h
index 0000000..1111111 100644
--- a/xbmc/windowing/gbm/drm/DRMConnector.h
+++ b/xbmc/windowing/gbm/drm/DRMConnector.h
@@ -40,6 +40,11 @@ public:
 
   std::vector<uint8_t> GetEDID() const;
 
+  bool SetContentType(uint32_t contentType);
+  bool DisableALLM();
+  uint32_t GetContentType() const;
+  bool HasContentTypeProperty() const;
+  bool IsHDMI() const;
 private:
   struct DrmModeConnectorDeleter
   {
diff --git a/xbmc/windowing/gbm/drm/DRMUtils.cpp b/xbmc/windowing/gbm/drm/DRMUtils.cpp
index 0000000..1111111 100644
--- a/xbmc/windowing/gbm/drm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/drm/DRMUtils.cpp
@@ -48,6 +48,12 @@ bool CDRMUtils::SetMode(const RESOLUTION_INFO& res)
             m_mode->hdisplay, m_mode->vdisplay, m_mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
             m_mode->vrefresh);
 
+  // Re-disable ALLM after mode change
+  if (m_connector->HasContentTypeProperty())
+  {
+    m_connector->DisableALLM();
+  }
+
   return true;
 }
 
@@ -388,6 +394,17 @@ bool CDRMUtils::InitDrm()
   if (!FindConnector())
     return false;
 
+  // Disable ALLM for HDR compatibility
+  if (m_connector->HasContentTypeProperty())
+  {
+    CLog::Log(LOGINFO, "CDRMUtils::{} - Disabling ALLM for better HDR compatibility", __FUNCTION__);
+    if (!m_connector->DisableALLM())
+    {
+      CLog::Log(LOGWARNING, "CDRMUtils::{} - Failed to disable ALLM, continuing anyway", __FUNCTION__);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "CDRMUtils::{} - Content type property not available on connector", __FUNCTION__);
+  }
+
   if (!FindEncoder())
     return false;
 
@@ -455,6 +472,13 @@ bool CDRMUtils::FindConnector()
             connector->get()->GetName());
 
   m_connector = connector->get();
+
+  // Disable ALLM on newly selected connector
+  if (m_connector->HasContentTypeProperty())
+  {
+    CLog::Log(LOGINFO, "CDRMUtils::{} - Disabling ALLM on connector: {}", __FUNCTION__, 
+              m_connector->GetName());
+    m_connector->DisableALLM();
+  }
   return true;
 }
 
-- 
2.39.0
