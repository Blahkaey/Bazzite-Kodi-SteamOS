#!/bin/bash
#
# Session Switch Handler Daemon
# Watches for session switch requests and handles transitions
#

set -euo pipefail

# Configuration
TRIGGER_FILE="/var/run/session-switch-request"
STATE_FILE="/var/lib/session-state"
LOCK_FILE="/var/run/session-switch.lock"
DISPLAY_METHOD_FILE="/var/run/display-wake-method"
SDDM_CONF="/etc/sddm.conf.d/zz-steamos-autologin.conf"
LOG_TAG="session-switch-handler"

# Logging functions
log_info() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $@"
}

log_warning() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $@" >&2
}

log_error() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $@" >&2
}

# Initialize runtime files
mkdir -p /var/run /var/lib
touch "$TRIGGER_FILE"
chmod 666 "$TRIGGER_FILE"
echo -n "" > "$TRIGGER_FILE"

# Initialize state file
if [[ ! -f "$STATE_FILE" ]]; then
    if systemctl is-active --quiet kodi-gbm.service; then
        echo "kodi" > "$STATE_FILE"
    elif systemctl is-active --quiet sddm.service; then
        echo "gamemode" > "$STATE_FILE"
    else
        echo "unknown" > "$STATE_FILE"
    fi
fi
chmod 644 "$STATE_FILE"

log_info "Session switch handler started"

# Function: Wait for process to exit with timeout
wait_for_process_exit() {
    local process_pattern="$1"
    local timeout="${2:-30}"  # Default 300 iterations (3 seconds)
    local count=0

    while pgrep -f "$process_pattern" >/dev/null && [ $count -lt $timeout ]; do
        sleep 0.01
        ((count++))
    done

    # Return success if process is gone
    ! pgrep -f "$process_pattern" >/dev/null
}

# Function: Wait for process to start with timeout
wait_for_process_start() {
    local process_name="$1"
    local timeout="${2:-20}"  # Default 200 iterations (2 seconds)
    local count=0

    while ! pgrep -x "$process_name" >/dev/null && [ $count -lt $timeout ]; do
        sleep 0.01
        ((count++))
    done

    # Return success if process started
    pgrep -x "$process_name" >/dev/null
}

# Function: Smart display wake with learning
wake_display() {
    # Read last method used
    local last_method=$(cat "$DISPLAY_METHOD_FILE" 2>/dev/null || echo "none")
    local next_method=""
    
    # Determine next method to try
    case "$last_method" in
        "none"|"drm_rescan")
            next_method="sysfs"
            ;;
        "sysfs")
            next_method="ddcutil"
            ;;
        "ddcutil")
            next_method="modetest"
            ;;
        "modetest")
            next_method="vt_switch"
            ;;
        "vt_switch")
            next_method="drm_rescan"
            ;;
        *)
            next_method="sysfs"
            ;;
    esac
    
    log_info "Testing display wake method: $next_method"
    
    case "$next_method" in
        "sysfs")
            log_info "Method 1: sysfs direct write (checking actual permissions)"
            local success=false
            
            for dpms in /sys/class/drm/card*-*/dpms; do
                if [ -f "$dpms" ]; then
                    local status_file="${dpms%/dpms}/status"
                    local connector=$(basename $(dirname "$dpms"))
                    local perms=$(stat -c %a "$dpms")
                    
                    log_info "  $connector: permissions=$perms, writable=$([[ -w "$dpms" ]] && echo "yes" || echo "no")"
                    
                    if [ -f "$status_file" ] && [ "$(cat "$status_file")" = "connected" ]; then
                        # Try even if not writable to see exact error
                        log_info "  Attempting write to $connector..."
                        if echo "On" > "$dpms" 2>/tmp/sysfs-error.log; then
                            log_info "  Success on $connector"
                            success=true
                        else
                            log_warning "  Write failed: $(cat /tmp/sysfs-error.log 2>/dev/null || echo "Permission denied")"
                        fi
                    fi
                fi
            done
            
            echo "sysfs" > "$DISPLAY_METHOD_FILE"
            ;;
            
        "ddcutil")
            log_info "Method 2: ddcutil with force and retry"
            if command -v ddcutil &>/dev/null; then
                # First try to force communication even if display is asleep
                log_info "  Forcing communication with sleeping display..."
                
                # Try multiple approaches
                log_info "  Attempt 1: Force with --force-slave-address"
                ddcutil --force-slave-address setvcp 0xD6 0x01 --bus=6 2>&1 | tee /tmp/ddcutil-force.log
                
                log_info "  Attempt 2: With extended sleep multiplier"
                ddcutil --sleep-multiplier=4.0 setvcp 0xD6 0x01 --bus=6 2>&1 | tee /tmp/ddcutil-sleep.log
                
                log_info "  Attempt 3: Skip DDC checks"
                ddcutil --skip-ddc-checks setvcp 0xD6 0x01 --bus=6 2>&1 | tee /tmp/ddcutil-skip.log
            else
                log_warning "  ddcutil not found"
            fi
            echo "ddcutil" > "$DISPLAY_METHOD_FILE"
            ;;
            
        "modetest")
            log_info "Method 3: modetest with atomic commit"
            if command -v modetest &>/dev/null; then
                # Get current state
                local conn_info=$(modetest -c 2>/dev/null | grep -A5 "^[0-9].*connected")
                log_info "  Current connector state:"
                echo "$conn_info" | head -10
                
                # Try to find DPMS property ID
                local connector_id=$(modetest -c 2>/dev/null | grep "connected" | grep -v "disconnected" | head -1 | awk '{print $1}')
                if [ -n "$connector_id" ]; then
                    log_info "  Using connector ID: $connector_id"
                    
                    # Method 1: Direct property set
                    log_info "  Attempt 1: Direct DPMS property"
                    modetest -w "${connector_id}:DPMS:0" 2>&1 | tee /tmp/modetest-direct.log
                    
                    # Method 2: Try with property ID if we can find it
                    local dpms_prop=$(modetest -c 2>/dev/null | grep -A20 "^${connector_id}\s" | grep "DPMS:" | awk '{print $1}')
                    if [ -n "$dpms_prop" ]; then
                        log_info "  Attempt 2: Using property ID $dpms_prop"
                        modetest -w "${connector_id}:${dpms_prop}:0" 2>&1 | tee /tmp/modetest-propid.log
                    fi
                fi
            else
                log_warning "  modetest not found"
            fi
            echo "modetest" > "$DISPLAY_METHOD_FILE"
            ;;
            
        "vt_switch")
            log_info "Method 4: VT switch with force"
            # Get current VT
            local current_vt=$(fgconsole 2>/dev/null || echo "1")
            log_info "  Current VT: $current_vt"
            
            # Try multiple VT switches to ensure display wake
            log_info "  Cycling through VTs..."
            for vt in 2 3 1; do
                log_info "  Switching to VT${vt}"
                chvt $vt 2>/dev/null || log_warning "  chvt $vt failed"
                sleep 0.1
            done
            
            # Also try to force text mode reset
            log_info "  Forcing text mode reset"
            echo 1 > /sys/class/vtconsole/vtcon0/bind 2>/dev/null || true
            
            echo "vt_switch" > "$DISPLAY_METHOD_FILE"
            ;;
            
        "drm_rescan")
            log_info "Method 6: Force DRM connector rescan"
            # Try to force a connector rescan
            for connector in /sys/class/drm/card*-*/status; do
                if [ -f "$connector" ]; then
                    local conn_name=$(basename $(dirname "$connector"))
                    log_info "  Triggering rescan on $conn_name"
                    # Reading status triggers a probe
                    cat "$connector" > /dev/null
                    
                    # Try to force detect if available
                    local detect_file="${connector%/status}/force"
                    if [ -f "$detect_file" ]; then
                        log_info "  Force detecting $conn_name"
                        echo "detect" > "$detect_file" 2>/dev/null || true
                    fi
                fi
            done
            
            # Also try to reload drm module state
            log_info "  Triggering DRM module reprobe"
            echo 1 > /sys/class/drm/card0/device/reset 2>/dev/null || true
            
            echo "drm_rescan" > "$DISPLAY_METHOD_FILE"
            ;;
    esac
    
    log_info "Next launch will test: $(cat "$DISPLAY_METHOD_FILE" 2>/dev/null || echo "unknown")"
}

# Function: Process cleanup
cleanup_processes() {
    local target="$1"

    case "$target" in
        kodi)
            # Try graceful termination
            pkill -TERM -f "kodi" 2>/dev/null || true
            # Short grace period
            sleep 0.2
            # Force kill if still running
            if pgrep -f "kodi" >/dev/null; then
                log_info "Force killing Kodi processes"
                pkill -KILL -f "kodi" 2>/dev/null || true
            fi
            ;;
        gaming)
            # Terminate Steam and Gamescope
            #pkill -TERM -f "steam" 2>/dev/null || true
            #pkill -TERM -f "gamescope" 2>/dev/null || true
            # Short grace period
            #sleep 0.2

            systemctl stop plugin_loader.service

            # Force kill if needed
            #if pgrep -f "steam|gamescope" >/dev/null; then
            #    log_info "Force killing gaming processes"
            #    pkill -KILL -f "steam" 2>/dev/null || true
                pkill -KILL -f "gamescope" 2>/dev/null || true
            #fi
            ;;
    esac
}

# Function: Switch to Kodi with retry logic
switch_to_kodi() {
    log_info "Switching to Kodi HDR mode..."

    # Quick check if already running
    if systemctl is-active --quiet kodi-gbm.service; then
        log_info "Already in Kodi mode"
        return 0
    fi

    # Stop SDDM if running
    if systemctl is-active --quiet sddm.service; then
        log_info "Stopping SDDM..."
        if ! systemctl stop sddm.service; then
            log_error "Failed to stop SDDM"
            return 1
        fi

        # Wait for gamescope to actually exit
        wait_for_process_exit "gamescope" 30 || {
            log_warning "Gamescope didn't exit cleanly, continuing anyway"
        }
    fi

    # Cleanup gaming processes
    cleanup_processes "gaming"

    # Ensure on TTY1
    chvt 1 2>/dev/null || true

    # Wake display before starting
    wake_display

    # Start Kodi
    if systemctl start kodi-gbm.service; then
        # Wait for Kodi to actually start
        if wait_for_process_start "kodi-gbm" 20; then
            echo "kodi" > "$STATE_FILE"
            #wake_display  # Wake again after start
            log_info "Successfully switched to Kodi"
            return 0
        else
            log_error "Kodi service started but process not found"
            systemctl stop kodi-gbm.service 2>/dev/null || true
        fi
    fi

    
    log_error "Failed to start Kodi, attempting recovery"

    # Recovery: Clear any stuck state and try once more
    systemctl reset-failed kodi-gbm.service 2>/dev/null || true
    pkill -KILL -f "kodi" 2>/dev/null || true
    sleep 0.5

    if systemctl start kodi-gbm.service; then
        if wait_for_process_start "kodi-gbm" 20; then
            echo "kodi" > "$STATE_FILE"
            wake_display
            log_info "Recovery successful - Kodi started"
            return 0
        fi
    fi

    log_error "Failed to start Kodi - recovery unsuccessful"
    echo "failed" > "$STATE_FILE"
    return 1
}

# Function: Switch to gaming mode with retry logic
switch_to_gamemode() {
    log_info "Switching to Gaming mode..."

    # Quick check if already running
    if systemctl is-active --quiet sddm.service; then
        log_info "Already in Gaming mode"
        return 0
    fi

    # Update SDDM config
    mkdir -p "$(dirname "$SDDM_CONF")"
    {
        echo "[Autologin]"
        echo "Session=gamescope-session.desktop"
    } > "$SDDM_CONF"

    # Stop Kodi if running
    if systemctl is-active --quiet kodi-gbm.service; then
        log_info "Stopping Kodi service..."
        systemctl stop kodi-gbm.service || true

        # Wait for Kodi to exit
        wait_for_process_exit "kodi-gbm" 20 || {
            log_warning "Kodi didn't exit cleanly, continuing anyway"
        }
    fi

    # Cleanup Kodi processes
    cleanup_processes "kodi"

    systemctl start plugin_loader.service
    sleep 0.1


    # Reset failed state
    systemctl reset-failed sddm.service 2>/dev/null || true

    if systemctl start sddm.service; then
        # Give SDDM a moment to initialize
        sleep 0.5

        if systemctl is-active --quiet sddm.service; then
            echo "gamemode" > "$STATE_FILE"
            log_info "Successfully switched to Gaming mode"
            return 0
        fi
    fi


    log_error "Failed to start SDDM, attempting recovery"

    # Kill any stuck processes
    pkill -KILL -f "sddm" 2>/dev/null || true
    sleep 0.5

    systemctl reset-failed sddm.service 2>/dev/null || true

    if systemctl start sddm.service; then
        echo "gamemode" > "$STATE_FILE"
        log_info "Recovery successful - SDDM started"
        return 0
    fi

    log_error "Failed to start SDDM - recovery unsuccessful"
    echo "failed" > "$STATE_FILE"
    return 1
}

# Main loop
log_info "Entering main loop, watching $TRIGGER_FILE"

while true; do
    # Wait for trigger file modification
    if inotifywait -e modify,create "$TRIGGER_FILE" 2>/dev/null; then
        # Lock to prevent concurrent switches
        exec 200>"$LOCK_FILE"
        if ! flock -n 200; then
            log_info "Another switch operation in progress, skipping..."
            continue
        fi

        # Read and clear the request
        REQUEST=$(cat "$TRIGGER_FILE" 2>/dev/null | tr -d '\n' | tr -d ' ')
        echo -n "" > "$TRIGGER_FILE"

        # Process the request
        case "$REQUEST" in
            "kodi")
                switch_to_kodi
                ;;
            "gamemode"|"gaming")
                switch_to_gamemode
                ;;
            "")
                # Empty request, ignore
                ;;
            *)
                log_error "Unknown request: $REQUEST"
                ;;
        esac

        # Release lock
        flock -u 200
    fi
done